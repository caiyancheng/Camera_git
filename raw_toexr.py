#!/usr/bin/env python
import glob
import sys
# sys.path.insert(0, "./HDRutils")
import HDRutils  # make sure to use version of HDRutils that contains deglare.py
import os.path as op
import os
import argparse
import numpy as np
import cv2
import scipy.io
import logging

logger = logging.getLogger(__name__)


class color_correction:
    def __init__(self, color_calibration_file=None) -> None:
        if color_calibration_file is None:
            logger.info('Skipping color calibration')
            self.color_matrix = np.eye(3)
            self.type = 'none'
        else:
            logger.info('Fetching color calibration matrix')
            try:
                data = scipy.io.loadmat(color_calibration_file)

                if 'type' in data:
                    self.type = data['type']
                else:
                    self.type = 'linear'

                M_nrgb2xyz = data['M_nrgb2xyz']
                M_xyz2rgb = np.array([[3.2406, -1.5372, -0.4986],
                                      [-0.9689, 1.8758, 0.0415],
                                      [0.0557, -0.2040, 1.0570]])
                self.color_matrix = (M_xyz2rgb @ M_nrgb2xyz).transpose()
                logger.info(f'Color correction: {self.type}')
                logger.info(f'Color matrix to use: {self.color_matrix}')
            except:
                logger.error(f'Could not load color calibration matrix: {self.color_matrix}')

    def _rgb2prod_polynomial(self, RGB, degrees=[0.5]):
        RGB_poly = np.copy(RGB)
        for kk in range(len(degrees)):
            p = degrees[kk]
            n = (1 - p)
            RGB_poly = np.concatenate((RGB_poly, RGB[:, :, 0:1] ** p * RGB[:, :, 1:2] ** n,
                                       RGB[:, :, 1:2] ** p * RGB[:, :, 2:3] ** n,
                                       RGB[:, :, 0:1] ** p * RGB[:, :, 2:3] ** n), axis=2)

        return RGB_poly

    def colour_calibrate(self, RGB):
        if self.type == 'none':
            return RGB
        elif self.type == 'linear':
            return RGB @ self.color_matrix
        elif self.type == 'root_polynomial':
            return self._rgb2prod_polynomial(RGB) @ self.color_matrix
        else:
            raise RuntimeError(f'Unknown color calibration type: {self.type}')


if __name__ == "__main__":
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('glob', type=str)
    parser.add_argument('--mtf_json', default='MTF/mtf_sony_a7R_FE_28_90.json', help=' ')
    parser.add_argument('-c', '--color-calibration',
                        default='sonyA7R3_iqled_color_matrix.mat',
                        help='merge: File containing color calibration matrix generated by Matlab. The matrix converts native RGB to Rec 709.')
    parser.add_argument('-o', '--output', default='merged.exr', help=' ')
    args = parser.parse_args()

if args.color_calibration is not None:
    if not op.isfile(args.color_calibration):
        sys.exit(args.color_calibration, "does not exit")

if args.mtf_json == "None":
    args.mtf_json = None

fnames = glob.glob(args.glob)
merged, unsaturated_mask = HDRutils.merge(fnames, color_space="raw", demosaic_first=False, wb=np.array([1., 1., 1.]),
                                          mtf_json=args.mtf_json, demosaic="bilinear")
color_corr = color_correction(args.color_calibration)
merged = color_corr.colour_calibrate(merged)
merged[np.logical_not(unsaturated_mask)] = merged.max()
merged = merged.clip(min=0)
HDRutils.imwrite(args.output, merged)
print("wrote ", args.output)
